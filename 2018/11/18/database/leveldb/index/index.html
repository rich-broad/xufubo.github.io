<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="概述近期在学习百度开源的BFS，其实现使用了LevelDB，对LevelDB产生了浓厚的兴趣，里边的很多技术点以及技术细节也一直是自己想了解的。本文章先从其官方使用文档开始，逐步分析LevelDB的实现。本篇文章主要是对LevelDB官方文档的翻译。 leveldbJeff Dean, Sanjay Ghemawatleveldb支持key-value形式的持久性存储。Keys和Values可以是">
<meta property="og:type" content="article">
<meta property="og:title" content="xufubo">
<meta property="og:url" content="http://yoursite.com/2018/11/18/database/leveldb/index/index.html">
<meta property="og:site_name" content="xufubo">
<meta property="og:description" content="概述近期在学习百度开源的BFS，其实现使用了LevelDB，对LevelDB产生了浓厚的兴趣，里边的很多技术点以及技术细节也一直是自己想了解的。本文章先从其官方使用文档开始，逐步分析LevelDB的实现。本篇文章主要是对LevelDB官方文档的翻译。 leveldbJeff Dean, Sanjay Ghemawatleveldb支持key-value形式的持久性存储。Keys和Values可以是">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-05-01T09:02:05.785Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="xufubo">
<meta name="twitter:description" content="概述近期在学习百度开源的BFS，其实现使用了LevelDB，对LevelDB产生了浓厚的兴趣，里边的很多技术点以及技术细节也一直是自己想了解的。本文章先从其官方使用文档开始，逐步分析LevelDB的实现。本篇文章主要是对LevelDB官方文档的翻译。 leveldbJeff Dean, Sanjay Ghemawatleveldb支持key-value形式的持久性存储。Keys和Values可以是">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/11/18/database/leveldb/index/">





  <title> | xufubo</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xufubo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/18/database/leveldb/index/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xufubo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xufubo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-18T22:56:10+08:00">
                2018-11-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>近期在学习百度开源的BFS，其实现使用了LevelDB，对LevelDB产生了浓厚的兴趣，里边的很多技术点以及技术细节也一直是自己想了解的。本文章先从其官方使用文档开始，逐步分析LevelDB的实现。<br>本篇文章主要是对LevelDB官方文档的翻译。</p>
<h1 id="leveldb"><a href="#leveldb" class="headerlink" title="leveldb"></a>leveldb</h1><p><em>Jeff Dean, Sanjay Ghemawat</em><br>leveldb支持key-value形式的持久性存储。Keys和Values可以是任意的字节数组。leveldb中的数据是根据用户提供的比较函数(comparator function)对key进行排序后将键值进行存储的。</p>
<h1 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h1><p>leveldb数据库以一个文件目录作为名字。数据库中的所有数据均存放在该目录下。以下实例示范了如何打开一个leveldb数据库，并且在数据库不存在时新建一个。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"leveldb/db.h"</span></span></span><br><span class="line"></span><br><span class="line">leveldb::DB* db;</span><br><span class="line">leveldb::Options options;</span><br><span class="line">options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line">leveldb::Status status = leveldb::DB::Open(options, <span class="string">"/tmp/testdb"</span>, &amp;db);</span><br><span class="line">assert(status.ok());</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>如果想要在数据库已存在时报错，则需要在调用leveldb::DB::Open之前调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options.error_if_exists = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="Status"><a href="#Status" class="headerlink" title="Status"></a>Status</h1><p>你可能注意到，在上面打开数据的例子中，返回值得类型为leveldb::Status。leveldb中的大部分可能返回失败状态的函数都返回该类型的值。用户可以检查返回值是否为ok，并且打印其携带的相关错误信息：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Status s = ...;</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) <span class="built_in">cerr</span> &lt;&lt; s.ToString() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="关闭数据库"><a href="#关闭数据库" class="headerlink" title="关闭数据库"></a>关闭数据库</h1><p>当不在使用数据库时，只需要删除对应的实例即可关闭数据库。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">... open the db as described above ...</span><br><span class="line">... <span class="keyword">do</span> something with db ...</span><br><span class="line"><span class="keyword">delete</span> db;</span><br></pre></td></tr></table></figure></p>
<h1 id="读操作和写操作"><a href="#读操作和写操作" class="headerlink" title="读操作和写操作"></a>读操作和写操作</h1><p>数据库提供了Put，Delete和Get方法来修改/查询数据库。例如，以下代码将存储在key1下的值移至key2下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> value;</span><br><span class="line">leveldb::Status s = db-&gt;Get(leveldb::ReadOptions(), key1, &amp;value);</span><br><span class="line"><span class="keyword">if</span> (s.ok()) s = db-&gt;Put(leveldb::WriteOptions(), key2, value);</span><br><span class="line"><span class="keyword">if</span> (s.ok()) s = db-&gt;Delete(leveldb::WriteOptions(), key1);</span><br></pre></td></tr></table></figure></p>
<h1 id="原子更新"><a href="#原子更新" class="headerlink" title="原子更新"></a>原子更新</h1><p>上面的读写例子中，如果程序在删除key1前退出，那么数据库中将会存在两个拥有相同value的key。这类问题可以通过使用WriteBatch类将一组更新操作作为原子动作执行。如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"leveldb/write_batch.h"</span></span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> value;</span><br><span class="line">leveldb::Status s = db-&gt;Get(leveldb::ReadOptions(), key1, &amp;value);</span><br><span class="line"><span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">  leveldb::WriteBatch batch;</span><br><span class="line">  batch.Delete(key1);</span><br><span class="line">  batch.Put(key2, value);</span><br><span class="line">  s = db-&gt;Write(leveldb::WriteOptions(), &amp;batch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>WriteBatch包含了对数据库进行的一系列操作。然后这些操作将会根据添加的顺序进行执行。注意该例中delete删除了key1放在了put操作之前，这样可以避免key1和key2相同的情况下，将key1和key2全部错误的删掉。<br>WriteBatch除了具有原子性的优势之外，你还可以将多个单个的操作放在同一个WriteBatch中以加快批量更新。</p>
<h1 id="同步写"><a href="#同步写" class="headerlink" title="同步写"></a>同步写</h1><p>默认情况下，对数据库的写操作是异步的：将数据从程序中写入操作系统后立即返回。数据从操作系统保存到底层的持久性存储器是异步的操作。通过打开sync标志，可以让写操作阻塞直到写入的数据全部被保存到持久存储器中。(在Posix系统中，可以通过在写操作中调用fsync(…)、fdatasync(…)或者msync(…, MS_SYNC)来实现)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leveldb::WriteOptions write_options;</span><br><span class="line">write_options.sync = <span class="literal">true</span>;</span><br><span class="line">db-&gt;Put(write_options, ...);</span><br></pre></td></tr></table></figure></p>
<p>异步写常常比同步写快千倍以上。但是异步写的缺点是如果机器crash的话会导致最近的几次操作更新丢失。然而，如果仅仅是写操作进程(而不是机器重启)crash的话则不会导致更新操作丢失，因为即使sync标识未打开，当一个写操作返回前，更新操作已经将数据从进程的内存空间传给了操作系统内核空间，操作系统会将这些数据写到持久性存储器中。<br>异步写通常可以安全的使用。例如，在加载大量数据数据到数据库时，若发生了crash，可以通过重启批量加载来处理丢失的更新操作。若是混合操作的情况下，如每隔几个异步写就插入一个同步写操作，在这样的情况下发生了crash，那么将在上一次运行的最后一个同步写操作结束后，重新启动批量加载。(同步写会更新一个标识用于记录crash后从何处重启)。<br>WriteBatch提供了异步写之外的另一种选择。多个更新操作可以放置于同一个WriteBatch中，然后已同步写的方式一起执行(即write_options.sync设置为true)。同步写的额外开销将被平摊给批量操作中的所有写操作。</p>
<h1 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h1><p>一个数据库同一时间只能被一个进程打开。为了防止误操作，leveldb会从操作系统获取一个锁。在一个进程中，同一个leveldb::DB的实例可以被多个线程并行共享使用，即不同的线程可以对同一个数据库同时执行写操作(write)，获取迭代器(iterators )，或者调用Get()方法，而不需要做任何额外的同步措施(leveldb内部实现会自动做同步)。然而其他类的实例(如Iterator和WriteBatch)则需要使用者在使用时进行同步。如果多个线程共享这样的对象，他们必须使用锁机制进行访问同步。更多的细节可以查看公共头文件。</p>
<h1 id="迭代-遍历-Iteration"><a href="#迭代-遍历-Iteration" class="headerlink" title="迭代/遍历(Iteration)"></a>迭代/遍历(Iteration)</h1><p>以下例子示范了如何打印数据库中所有的键值对：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Iterator* it = db-&gt;NewIterator(leveldb::ReadOptions());</span><br><span class="line"><span class="keyword">for</span> (it-&gt;SeekToFirst(); it-&gt;Valid(); it-&gt;Next()) &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; it-&gt;key().ToString() &lt;&lt; <span class="string">": "</span>  &lt;&lt; it-&gt;value().ToString() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">assert(it-&gt;status().ok());  <span class="comment">// Check for any errors found during the scan</span></span><br><span class="line"><span class="keyword">delete</span> it;</span><br></pre></td></tr></table></figure></p>
<p>在此基础上修改，示范怎么处理key在[start,limit)区间内的数据：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (it-&gt;Seek(start);</span><br><span class="line">   it-&gt;Valid() &amp;&amp; it-&gt;key().ToString() &lt; limit;</span><br><span class="line">   it-&gt;Next()) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以以相反的顺序处理数据：(警告：倒序迭代会比正序迭代稍微慢一些)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (it-&gt;SeekToLast(); it-&gt;Valid(); it-&gt;Prev()) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="快照-Snapshots"><a href="#快照-Snapshots" class="headerlink" title="快照(Snapshots)"></a>快照(Snapshots)</h1><p>快照代表了数据库的所有键值数据在某一时间点的状态，提供了一致的读视图。ReadOptions::snapshot为非空时，表示读操作应该在一个特定版本的数据库状态上进行操作。如果ReadOptions::snapshot为空，读操作将隐式的在数据库的当前状态上进行操作。<br>快照可以通过DB::GetSnapshot()方法构造：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leveldb::ReadOptions options;</span><br><span class="line">options.snapshot = db-&gt;GetSnapshot();</span><br><span class="line">... apply some updates to db ...</span><br><span class="line">leveldb::Iterator* iter = db-&gt;NewIterator(options);</span><br><span class="line">... read <span class="keyword">using</span> iter to view the state when the snapshot was created ...</span><br><span class="line"><span class="keyword">delete</span> iter;</span><br><span class="line">db-&gt;ReleaseSnapshot(options.snapshot);</span><br></pre></td></tr></table></figure></p>
<p>当快照不再需要时，要通过DB::ReleaseSnapshot接口进行释放。这允许实现摆脱为维持读取快照而维护的状态。</p>
<h1 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h1><p>在上面的代码中，it-&gt;key() 和it-&gt;value()方法的返回值类型为leveldb::Slice。Slice是包含一个指向外部字节数组的指针以及字节数组长度的简单结构。相比于返回std::string，返回一个Slice的开销更小，因为不需要隐式的拷贝键值数据。另外，leveldb的方法不返回C语言形式的以’\0’结束的字符串，因为leveldb的key和value都允许包含’\0’。<br>C++ string和C风格形式字符串可以很简单的转换为Slice类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Slice s1 = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line">leveldb::Slice s2 = str;</span><br></pre></td></tr></table></figure></p>
<p>Slice类型也可以很简单的转换为C++ string：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str = s1.ToString();</span><br><span class="line">assert(str == <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"hello"</span>));</span><br></pre></td></tr></table></figure></p>
<p>必须要注意的是在使用Slice期间Slice中的指针所指向的字节数组必须是有效的。例如，以下场景就是错误的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Slice slice;</span><br><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str = ...;</span><br><span class="line">  slice = str;</span><br><span class="line">&#125;</span><br><span class="line">Use(slice);</span><br></pre></td></tr></table></figure></p>
<p>当离开if的作用域是，str将会被销毁，slice的指针将指向一个非法的地址。</p>
<h1 id="比较器-Comparators"><a href="#比较器-Comparators" class="headerlink" title="比较器(Comparators)"></a>比较器(Comparators)</h1><p>之前的里例子中，使用了默认的按照字母顺序比较的方法对key进行顺序排序。Leveldb支持自定义的排序方法。例如，假设key是由2个数字组成的结构，排序时首先使用第一个数字做比较，若第一个数字相等，再使用第二个数字做比较。首先，需要继承leveldb::Comparator的实现一个子类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoPartComparator</span> :</span> <span class="keyword">public</span> leveldb::Comparator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Three-way comparison function:</span></span><br><span class="line">  <span class="comment">//   if a &lt; b: negative result</span></span><br><span class="line">  <span class="comment">//   if a &gt; b: positive result</span></span><br><span class="line">  <span class="comment">//   else: zero result</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Compare</span><span class="params">(<span class="keyword">const</span> leveldb::Slice&amp; a, <span class="keyword">const</span> leveldb::Slice&amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a1, a2, b1, b2;</span><br><span class="line">    ParseKey(a, &amp;a1, &amp;a2);</span><br><span class="line">    ParseKey(b, &amp;b1, &amp;b2);</span><br><span class="line">    <span class="keyword">if</span> (a1 &lt; b1) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a1 &gt; b1) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a2 &lt; b2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a2 &gt; b2) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ignore the following methods for now:</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"TwoPartComparator"</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">FindShortestSeparator</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>*, <span class="keyword">const</span> leveldb::Slice&amp;)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">FindShortSuccessor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>*)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后创建一个使用该比较器的数据库：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TwoPartComparator cmp;</span><br><span class="line">leveldb::DB* db;</span><br><span class="line">leveldb::Options options;</span><br><span class="line">options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line">options.comparator = &amp;cmp;</span><br><span class="line">leveldb::Status status = leveldb::DB::Open(options, <span class="string">"/tmp/testdb"</span>, &amp;db);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h1 id="向后兼容-Backwards-compatibility"><a href="#向后兼容-Backwards-compatibility" class="headerlink" title="向后兼容(Backwards compatibility)"></a>向后兼容(Backwards compatibility)</h1><p>数据库被创建时，指定的比较器(leveldb::Comparator)的Name方法的返回值将会被保存起来；之后每一次打开数据库时，都会检查该值是否与本次打开指定的比较器的Name方法的返回值匹配。如果名字变了，那么 leveldb::DB::Open方法就会返回失败。因此，只有在新的key格式和比较器无法与现有的数据库兼容是，可以使用新的名称；同时，现在有的数据库的所有数据都讲被丢弃。<br>然而，通过提前制定计划也可以实现key格式的逐渐改变。例如，在每个key的末尾中保存一个版本号(一个字节通常够用了)，当需要修改key的格式的时，可以在不修改比较器名称的前提下，增加版本号的值，然后修改比较器的比较函数，使其通过区分key中的版本号，来做不同的处理。</p>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>通过修改一些参数可以调整leveldb的性能，可以在include/leveldb/options.h中查看定义。</p>
<h2 id="块大小"><a href="#块大小" class="headerlink" title="块大小"></a>块大小</h2><p>leveldb将相邻的keys聚集在一起放进同一个块中，将块作为写入或者从持久性存储器中读取的单元。默认的块大小大约为4096个未压缩字节。主要对数据库内容做批量扫描的应用不妨增加块的大小。若应用有很多读取小数据的地方，不妨在配合性能测试的条件下，选择一个更小的块大小。当块尺寸小于1K bytes或者大于几M bytes时，性能将不会显著提升。注意更大的块尺寸可以让压缩有更好的效果。</p>
<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>每个块在被写入持久存储前都会被压缩。leveldb默认是允许压缩的，因为默认的压缩方法是很快的。对不可压缩数据的将自动关闭压缩功能。在极少数情况下，应用程序可能希望完全禁用压缩，但只有在基准测试显示性能有所改进时才应该这样做.禁止方法如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Options options;</span><br><span class="line">options.compression = leveldb::kNoCompression;</span><br><span class="line">... leveldb::DB::Open(options, name, ...) ....</span><br></pre></td></tr></table></figure></p>
<h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2><p>leveldb的数据是以一些列文件的形式存放在文件系统中的，每个文件中存放了一系列经过压缩的块。如果options.cache非空，那么他将被用来存放频繁使用的未压缩的块数据。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"leveldb/cache.h"</span></span></span><br><span class="line"></span><br><span class="line">leveldb::Options options;</span><br><span class="line">options.cache = leveldb::NewLRUCache(<span class="number">100</span> * <span class="number">1048576</span>);  <span class="comment">// 100MB cache</span></span><br><span class="line">leveldb::DB* db;</span><br><span class="line">leveldb::DB::Open(options, name, &amp;db);</span><br><span class="line">... use the db ...</span><br><span class="line"><span class="keyword">delete</span> db</span><br><span class="line"><span class="keyword">delete</span> options.cache;</span><br></pre></td></tr></table></figure></p>
<p>必须要注意的是缓存中存放的是未压缩的数据，因此应该根据应用程序的数据来确定其大小，而不应该把压缩带来的数据尺寸变小考虑在内。(缓存压缩过的块数据是由操作系统负责，或者客户端定制Env来实现) 当执行批量读操作时，应用程序可能希望禁止缓存功能以防止批量读操作破坏cache中已经缓存的内容。可以通过设置迭代器的来达到该目的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">leveldb::ReadOptions options;</span><br><span class="line">options.fill_cache = <span class="literal">false</span>;</span><br><span class="line">leveldb::Iterator* it = db-&gt;NewIterator(options);</span><br><span class="line"><span class="keyword">for</span> (it-&gt;SeekToFirst(); it-&gt;Valid(); it-&gt;Next()) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="键布局-Key-Layout"><a href="#键布局-Key-Layout" class="headerlink" title="键布局(Key Layout)"></a>键布局(Key Layout)</h2><p>注意磁盘传输和缓存的单位是块。相邻的键(根据数据库的排序顺序)通常被放在同一个块中。因此应用程序可以把那些需要同时存取的键放在相邻的位置，不常用的键合拢单独放在一个位置，以此来提高性能。<br>例如，假设我们以leveldb为基础，实现一个文件系统。存储的条目类型不放设置以下格式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filename -&gt; permission-bits, length, <span class="built_in">list</span> of file_block_ids</span><br><span class="line">file_block_id -&gt; data</span><br><span class="line"><span class="comment">// 其中，&lt;k = filename, v = filemetadata&gt;,&lt;k = file_block_id, v = file_block_data&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我们可能需要在filename前加一个字母(例如’/’)作为前缀，在file_block_id前加一个不同的字母(例如’0’)，这样扫描只需要检查元数据而不需要强制我们读取和缓存笨重的文件内容(因为这样就会保证<k =="" filename,="" v="filemetadata">和<k =="" file_block_id,="" v="file_block_data">不会同时存在于一个块中，这样就使得扫描文件系统元数据会大大加快，仅需要扫描很少一部分数据。如果不这样做，<k =="" filename,="" v="filemetadata">和<k =="" file_block_id,="" v="file_block_data">有可能会保存在同一个块中，这时候，扫描文件系统元数据，就需要扫描leveldb数据库的所有数据。)。</k></k></k></k></p>
<h2 id="过滤器-Filters"><a href="#过滤器-Filters" class="headerlink" title="过滤器(Filters)"></a>过滤器(Filters)</h2><p>由于leveldb的数据在磁盘上的组织方式，一个Get()方法可能导致多次从磁盘读取数据。可选的FilterPolicy机制可以用来减少读磁盘的次数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Options options;</span><br><span class="line">options.filter_policy = NewBloomFilterPolicy(<span class="number">10</span>);</span><br><span class="line">leveldb::DB* db;</span><br><span class="line">leveldb::DB::Open(options, <span class="string">"/tmp/testdb"</span>, &amp;db);</span><br><span class="line">... use the database ...</span><br><span class="line"><span class="keyword">delete</span> db;</span><br><span class="line"><span class="keyword">delete</span> options.filter_policy;</span><br></pre></td></tr></table></figure></p>
<p>上述代码将一个基于Bloom_filter算法的过滤策略与数据库联系起来。基于Bloom_filter算法的过滤策略为每个键保存若干个bit的数据在内存中(根据传给NewBloomFilterPolicy的参数，该例中将为每个key保存10个bit的数据)。该过滤器会将Get()方法需要的不必要磁盘读操作数量降低大约100倍。增加保存的bit数量会大幅的减少磁盘读操作，但是也会占用更多的内存。我们建议为工作集不适合在内存中并且做大量随机读操作的应用程序设置一个过滤策略。<br>如果使用一个定制的比较器，那么应该保证正在使用的过滤策略和比较器是互相兼容的。例如，假设一个比较器在比较key时忽略尾随空格，那么NewBloomFilterPolicy不能和这样的比较器一起使用。此时应用程序应该提供一个忽略尾随空格的过滤策略与该比较器一起使用。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomFilterPolicy</span> :</span> <span class="keyword">public</span> leveldb::FilterPolicy &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  FilterPolicy* builtin_policy_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  CustomFilterPolicy() : builtin_policy_(NewBloomFilterPolicy(<span class="number">10</span>)) &#123;&#125;</span><br><span class="line">  ~CustomFilterPolicy() &#123; <span class="keyword">delete</span> builtin_policy_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"IgnoreTrailingSpacesFilter"</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="keyword">const</span> Slice* keys, <span class="keyword">int</span> n, <span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use builtin bloom filter code after removing trailing spaces</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Slice&gt; trimmed(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      trimmed[i] = RemoveTrailingSpaces(keys[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builtin_policy_-&gt;CreateFilter(&amp;trimmed[i], n, dst);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>高级应用程序可能会提供不使用布隆过滤器(bloom filter)的过滤策略，但使用其他一些机制来概括一组健，细节参考：leveldb/filter_policy.h。</p>
<h1 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h1><p>leveldb对所有它存放在文件系统的数据计算校验和。leveldb提供两个独立的选项来控制数据校验的严格程度。<br>ReadOptions::verify_checksums设置为true，则对所有从文件系统中读取的数据进行校验和检查。默认不会进行该检查。<br>在打开数据库之前，可以将Options :: paranoid_checks设置为true，以便在数据库实现检测到内部损坏后立即引发错误。根据数据库的哪一部分被损坏，数据库打开时可能会引发错误，或者稍后由另一个数据库操作引发错误。默认情况下该选项是关闭的，以便数据库可以在部分已经损坏的情况下继续使用。<br>如果数据库已经被损坏(或许无法再Options::paranoid_checks为true时被打开)，leveldb::RepairDB方法可以用来尽可能的恢复数据。</p>
<h1 id="近似大小"><a href="#近似大小" class="headerlink" title="近似大小"></a>近似大小</h1><p>GetApproximateSizes方法可用于获取一个或多个键范围的数据使用的文件系统空间的近似字节数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Range ranges[<span class="number">2</span>];</span><br><span class="line">ranges[<span class="number">0</span>] = leveldb::Range(<span class="string">"a"</span>, <span class="string">"c"</span>);</span><br><span class="line">ranges[<span class="number">1</span>] = leveldb::Range(<span class="string">"x"</span>, <span class="string">"z"</span>);</span><br><span class="line"><span class="keyword">uint64_t</span> sizes[<span class="number">2</span>];</span><br><span class="line">leveldb::Status s = db-&gt;GetApproximateSizes(ranges, <span class="number">2</span>, sizes);</span><br></pre></td></tr></table></figure></p>
<p>执行上述代码后，sizes[0]将保存[a..c)范围内所有key保存在文件系统中估计需占用的空间大小，sizes[1]将保存[x..z)范围内所有key保存在文件系统中估计需要占用的空间大小。</p>
<h1 id="环境-Environment"><a href="#环境-Environment" class="headerlink" title="环境(Environment)"></a>环境(Environment)</h1><p>leveldb发起的所有文件操作和其他的系统调用，都需要通过一个leveldb::Env对象来路由。有经验的客户可能希望提供他们自己的Env实现以获得更好的控制。例如，应用程序可能会在文件IO操作路径中引入人为的延迟，以限制leveldb对系统中其他活动的影响<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlowEnv</span> :</span> <span class="keyword">public</span> leveldb::Env &#123;</span><br><span class="line">  ... implementation of the Env interface ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SlowEnv env;</span><br><span class="line">leveldb::Options options;</span><br><span class="line">options.env = &amp;env;</span><br><span class="line">Status s = leveldb::DB::Open(options, ...);</span><br></pre></td></tr></table></figure></p>
<h1 id="可移植性-Porting"><a href="#可移植性-Porting" class="headerlink" title="可移植性(Porting)"></a>可移植性(Porting)</h1><p>通过实现leveldb/port/port.h中的与平台相关的types/methods/functions，leveldb可以移植到新的平台上，参考：leveldb/port/port_example.h<br>另外，新平台可能需要一个新的默认leveldb::Env实现。参考：leveldb/util/env_posix.h</p>
<h1 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h1><p>有关leveldb实现的细节可以在以下文档中找到：</p>
<ol>
<li><a href="impl.md">实现说明</a></li>
<li><a href="table_format.md">immutable Table文件格式</a></li>
<li><a href="log_format.md">日志文件格式</a></li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/18/database/leveldb/impl/" rel="next" title="">
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/11/18/database/leveldb/log_format/" rel="prev" title="">
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">xufubo</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leveldb"><span class="nav-number">2.</span> <span class="nav-text">leveldb</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#打开数据库"><span class="nav-number">3.</span> <span class="nav-text">打开数据库</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Status"><span class="nav-number">4.</span> <span class="nav-text">Status</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#关闭数据库"><span class="nav-number">5.</span> <span class="nav-text">关闭数据库</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#读操作和写操作"><span class="nav-number">6.</span> <span class="nav-text">读操作和写操作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#原子更新"><span class="nav-number">7.</span> <span class="nav-text">原子更新</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#同步写"><span class="nav-number">8.</span> <span class="nav-text">同步写</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#并发性"><span class="nav-number">9.</span> <span class="nav-text">并发性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#迭代-遍历-Iteration"><span class="nav-number">10.</span> <span class="nav-text">迭代/遍历(Iteration)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#快照-Snapshots"><span class="nav-number">11.</span> <span class="nav-text">快照(Snapshots)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Slice"><span class="nav-number">12.</span> <span class="nav-text">Slice</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#比较器-Comparators"><span class="nav-number">13.</span> <span class="nav-text">比较器(Comparators)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#向后兼容-Backwards-compatibility"><span class="nav-number">14.</span> <span class="nav-text">向后兼容(Backwards compatibility)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#性能"><span class="nav-number">15.</span> <span class="nav-text">性能</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#块大小"><span class="nav-number">15.1.</span> <span class="nav-text">块大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#压缩"><span class="nav-number">15.2.</span> <span class="nav-text">压缩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cache"><span class="nav-number">15.3.</span> <span class="nav-text">cache</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#键布局-Key-Layout"><span class="nav-number">15.4.</span> <span class="nav-text">键布局(Key Layout)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过滤器-Filters"><span class="nav-number">15.5.</span> <span class="nav-text">过滤器(Filters)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#校验和"><span class="nav-number">16.</span> <span class="nav-text">校验和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#近似大小"><span class="nav-number">17.</span> <span class="nav-text">近似大小</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#环境-Environment"><span class="nav-number">18.</span> <span class="nav-text">环境(Environment)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#可移植性-Porting"><span class="nav-number">19.</span> <span class="nav-text">可移植性(Porting)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#其他信息"><span class="nav-number">20.</span> <span class="nav-text">其他信息</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xufubo</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
